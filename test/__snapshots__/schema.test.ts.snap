// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Schema schema.grapqhl snapshot 1`] = `
"### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Category {
  id: ID!
  name: String!
  posts(first: Int, last: Int, orderBy: PostOrderByInput, skip: Int, where: PostWhereInput): [Post!]!
}

input CategoryCreateInput {
  name: String!
  posts: CreateCategoriesPostsRelationInput
}

input CategoryCreateWithoutPostsInput {
  name: String!
}

input CategoryOrderByInput {
  id: OrderByArgument
  name: OrderByArgument
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  id: IdFilter
  name: StringFilter
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  name: String
}

input CreateCategoriesPostsRelationInput {
  connect: PostWhereInput
  create: [PostCreateWithoutCategoriesInput!]
}

input CreatePostsCategoriesRelationInput {
  connect: CategoryWhereInput
  create: [CategoryCreateWithoutPostsInput!]
}

input CreatePostsUserLikesPostsRelationInput {
  connect: UserLikesPostWhereInput
  create: [UserLikesPostCreateWithoutPostInput!]
}

input CreatePostToUserRelationInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input CreateUserFollowsToFollowerRelationInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutFolloweesInput
}

input CreateUserLikesPostToPostRelationInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutUserLikesPostsInput
}

input CreateUserLikesPostToUserRelationInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input CreateUsersFolloweesRelationInput {
  connect: UserFollowsWhereInput
  create: [UserFollowsCreateWithoutFolloweeInput!]
}

input CreateUsersPostsRelationInput {
  connect: PostWhereInput
  create: [PostCreateWithoutUserInput!]
}

input CreateUsersUserLikesPostsRelationInput {
  connect: UserLikesPostWhereInput
  create: [UserLikesPostCreateWithoutUserInput!]
}

input CreateUserToEmailRelationInput {
  connect: EmailWhereUniqueInput
  create: EmailCreateWithoutUserInput
}

input CreateUserToProfileRelationInput {
  connect: UserProfileWhereUniqueInput
  create: UserProfileCreateWithoutUserInput
}

\\"\\"\\"
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
\`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
\\"\\"\\"
scalar DateTime

type Email {
  address: String!
  id: ID!
  user: User!
}

input EmailCreateWithoutUserInput {
  address: String!
}

input EmailWhereUniqueInput {
  id: ID
}

input IdFilter {
  equals: ID
  in: [ID!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
}

type Mutation {
  createOneCategory(data: CategoryCreateInput!): Category!
  createOnePost(data: PostCreateInput!): Post!
  createOneUser(data: UserCreateInput!): User!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): UpdateManyResult!
  updateOnePost(data: PostUpdateInput!, where: PostWhereInput!): Post!
  updateOneUser(data: UserUpdateInput!, where: UserWhereInput!): User!
}

enum OrderByArgument {
  ASC
  DESC
}

type Post {
  categories(first: Int, last: Int, orderBy: CategoryOrderByInput, skip: Int, where: CategoryWhereInput): [Category!]!
  createdAt: DateTime!
  id: ID!
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: User!
  userId: Int
  userLikesPosts(first: Int, last: Int, orderBy: UserLikesPostOrderByInput, skip: Int, where: UserLikesPostWhereInput): [UserLikesPost!]!
  viewCount: Int
}

input PostCreateInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutCategoriesInput {
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutUserInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  userLikesPosts: CreatePostsUserLikesPostsRelationInput
  viewCount: Int
}

input PostCreateWithoutUserLikesPostsInput {
  categories: CreatePostsCategoriesRelationInput
  createdAt: DateTime
  isPublic: Boolean!
  liked: String
  title: String!
  totalLikes: Int
  user: CreatePostToUserRelationInput
  userId: Int
  viewCount: Int
}

input PostOrderByInput {
  createdAt: OrderByArgument
  id: OrderByArgument
  isPublic: OrderByArgument
  liked: OrderByArgument
  title: OrderByArgument
  totalLikes: OrderByArgument
  userId: OrderByArgument
  viewCount: OrderByArgument
}

input PostUpdateInput {
  createdAt: DateTime
  isPublic: Boolean
  liked: String
  title: String
  totalLikes: Int
  userId: Int
  viewCount: Int
}

input PostWhereInput {
  AND: [PostWhereInput!]
  createdAt: DateTime
  id: IdFilter
  isPublic: Boolean
  liked: StringFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  title: StringFilter
  totalLikes: IntFilter
  userId: IntFilter
  viewCount: IntFilter
}

input PostWhereUniqueInput {
  id: ID
  title: String
}

type Query {
  category(where: CategoryWhereUniqueInput): Category!
  post(where: PostWhereUniqueInput): Post!
  posts(first: Int, last: Int, orderBy: PostOrderByInput, skip: Int, where: PostWhereInput): [Post!]!
  postsByCategoryId(categoryId: String!, first: Int, last: Int, orderBy: PostOrderByInput, skip: Int, where: PostWhereInput): [Post!]!
  user(where: UserWhereUniqueInput): User!
  users(first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersByName(first: Int, last: Int, name: String!, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
}

input StringFilter {
  contains: String
  equals: String
  in: [String!]
}

type UpdateManyResult {
  affectedRows: Int!
}

type User {
  age: Int
  email: Email!
  followees(first: Int, last: Int, orderBy: UserFollowsOrderByInput, skip: Int, where: UserFollowsWhereInput): [UserFollows!]!
  followers(first: Int, last: Int, orderBy: UserFollowsOrderByInput, skip: Int, where: UserFollowsWhereInput): [User!]!
  id: ID!
  name: String!
  posts(first: Int, last: Int, orderBy: PostOrderByInput, skip: Int, where: PostWhereInput): [Post!]!
  profile: UserProfile!
  type: UserTypeEnum!
  userLikesPosts(first: Int, last: Int, orderBy: UserLikesPostOrderByInput, skip: Int, where: UserLikesPostWhereInput): [UserLikesPost!]!
}

input UserCreateInput {
  age: Int
  email: CreateUserToEmailRelationInput
  followees: CreateUsersFolloweesRelationInput
  name: String!
  posts: CreateUsersPostsRelationInput
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

input UserCreateWithoutFolloweesInput {
  age: Int
  email: CreateUserToEmailRelationInput
  name: String!
  posts: CreateUsersPostsRelationInput
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

input UserCreateWithoutPostsInput {
  age: Int
  email: CreateUserToEmailRelationInput
  followees: CreateUsersFolloweesRelationInput
  name: String!
  profile: CreateUserToProfileRelationInput
  type: UserTypeEnum!
  userLikesPosts: CreateUsersUserLikesPostsRelationInput
}

type UserFollows {
  followee: User!
  followeeId: Int!
  follower: User!
  followerId: Int!
  id: ID!
}

input UserFollowsCreateWithoutFolloweeInput {
  follower: CreateUserFollowsToFollowerRelationInput
  followerId: Int!
}

input UserFollowsOrderByInput {
  followeeId: OrderByArgument
  followerId: OrderByArgument
  id: OrderByArgument
}

input UserFollowsWhereInput {
  AND: [UserFollowsWhereInput!]
  followeeId: IntFilter
  followerId: IntFilter
  id: IdFilter
  NOT: [UserFollowsWhereInput!]
  OR: [UserFollowsWhereInput!]
}

type UserLikesPost {
  id: ID!
  post: Post!
  postId: Int!
  user: User!
  userId: Int!
}

input UserLikesPostCreateWithoutPostInput {
  user: CreateUserLikesPostToUserRelationInput
  userId: Int!
}

input UserLikesPostCreateWithoutUserInput {
  post: CreateUserLikesPostToPostRelationInput
  postId: Int!
}

input UserLikesPostOrderByInput {
  id: OrderByArgument
  postId: OrderByArgument
  userId: OrderByArgument
}

input UserLikesPostWhereInput {
  AND: [UserLikesPostWhereInput!]
  id: IdFilter
  NOT: [UserLikesPostWhereInput!]
  OR: [UserLikesPostWhereInput!]
  postId: IntFilter
  userId: IntFilter
}

input UserOrderByInput {
  age: OrderByArgument
  email: OrderByArgument
  id: OrderByArgument
  name: OrderByArgument
  type: OrderByArgument
}

type UserProfile {
  displayName: String!
  id: ID!
  slug: String!
  user: User!
  userId: Int!
}

input UserProfileCreateWithoutUserInput {
  displayName: String!
  slug: String!
}

input UserProfileWhereUniqueInput {
  id: ID
  userId: Int
}

enum UserTypeEnum {
  ADMIN
  NORMAL
}

input UserUpdateInput {
  age: Int
  email: Int
  name: String
  type: UserTypeEnum
}

input UserWhereInput {
  age: IntFilter
  AND: [UserWhereInput!]
  id: IdFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  type: UserTypeEnum
}

input UserWhereUniqueInput {
  id: ID
  name: String
}
"
`;
